# 이벤트 드리븐 아키텍처 채택 이유와 Kafka vs RabbitMQ 

--- 

이 글에서는 프로젝트 아키텍처로 이벤트 드리븐 방식을 채택한 이유를 설명합니다. 
또한, 여러 메시지 시스템 중 Kafka와 RabbitMQ를 비교 검토하고 최종적으로 Kafka를 선택하게 된
과정을 다룹니다. <br></br>

### 📌 이벤트 드리븐 아키텍처 채택 이유:
본 가상 자산 거래소 프로젝트는 '주문 → 체결 → 정산'의 흐름으로 구성됩니다. 이 기능들을 하나의 
시스템으로 통합 관리할 경우, 여러 기술적인 한계가 발생합니다. <br>

예를 들어, 정산 기능의 작은 오류가 주문 및 체결 시스템 전체를 마비시키는 단일 장애점이 될 수 있어
안정성이 크게 저하됩니다. 또한 주문량이 급증할 때, 불필요한 기능까지 함께 확장해야 하므로 확장성이 
떨어지고 자원이 낭비됩니다. 이 외에도 성능 병목, 느린 개발 속도와 배포 등 명확한 단점들이 존재합니다. <br>

이러한 문제들로 인해서 각 서비스를 독립적으로 개발, 배포, 확장하여 시스템 전체의 유연성과 안정성을 
극대화할 수 있는 이벤트 드리븐 아키텍처를 채택하게 되었습니다.
<br></br>


### 📌 이벤트 드리븐 아키텍처:
![이벤트 드리븐](images/event_driven.png)
<br>

그럼 간단하게 이벤트 드리븐 아키텍처에 대해 살펴보겠습니다. <br>

이벤트 드리븐 아키텍처는 시스템의 여러 부분이 '이벤트'를 통해 서로 통신하는 소프트웨어 설계 방식입니다.
어떤 사건이 발생했다는 사실, 즉 '이벤트'가 생기면 이를 필요로 하는 다른 부분에 전달하여 작업을 처리하게 
하는 구조입니다. 이는 한 부분에서 다른 부분을 직접 호출하는 전통적인 요청-응답 방식과 달리, 서비스 간의 
의존성을 크게 낮추는 느슨한 결합이 가장 큰 특징입니다. <br>

하지만 이벤트 드리븐 방식에도 장단점이 존재합니다.
#### 장점:
- 확장성과 유연성: 서비스들이 독립적으로 작동하므로, 특정 서비스에 부하가 몰리면 해당 서비스만 확장하면
됩니다. 또한 새로운 기능을 추가할 때도 기존 시스템에 미치는 영향을 최소화하며 유연하게 추가할 수 있습니다.
- 높은 회복탄력성: 하나의 서비스에 장애가 발생하더라도, 이벤트 브로커가 이벤트를 보관하고 있다가 서비스가 
복구되면 전달할 수 있습니다. 이로 인해 전체 시스템의 장애로 확산될 가능성이 작아집니다.
- 비동기 통신: 이벤트를 발생시킨 후 응답을 기다리지 않고 다음 작업을 수행할 수 있어 시스템 전체의 응답 
속도와 처리 효율이 향상됩니다. 실시간 데이터 처리나 대규모 트래픽 처리에 매우 유리합니다.

#### 단점:
- 복잡성 증가: 이벤트의 흐름을 한눈에 파악하기 어렵고, 전체 시스템의 동작을 예측하고 디버깅하기가 더 
복잡해질 수 있습니다.
- 데이터 일관성 유지의 어려움: 데이터를 비동기적, 분산적으로 처리하므로 여러 서비스에 걸친 데이터의 최종 
일관성을 보장하기 위한 추가적인 설계(예: Saga 패턴)가 필요합니다.
- 이벤트 브로커에 대한 높은 의존성: 모든 통신의 중심인 이벤트 브로커에 장애가 발생하면 전체 시스템이 멈출
수 있습니다. 따라서 브로커 자체의 고가용성을 확보하는 것이 매우 중요합니다.

이러한 장단점을 가상자산 거래소의 핵심 요구사항에 비추어 판단했을 때, 이벤트 드리븐 아키텍처가 가장 적합한 
구조라고 결론 내렸습니다. 거래소는 폭증하는 거래량과 실시간 시세 변동을 지연 없이 처리해야 합니다. 
이는 이벤트 드리븐 아키텍처의 비동기 통신을 통한 높은 처리 효율과 유연한 확장성이 결정적인 장점으로 작용하는
지점입니다. 특정 서비스에 부하가 집중될 때 해당 부분만 신속하게 확장하여 대응할 수 있기 때문입니다. <br>

물론, 분산 처리로 인한 데이터 일관성 문제나 전체 흐름 파악의 어려움이라는 단점이 존재합니다. 
하지만 이는 사가 패턴과 같은 보상 트랜잭션 설계를 도입하는 등의 방법으로 충분히 관리 가능한 영역입니다.
반면, 단일 시스템의 구조적 한계로는 거래소의 핵심 가치인 안정성과 확장성을 확보하기 어렵습니다. <br>

따라서 일부 복잡성을 감수하더라도, 실시간 대규모 트래픽 처리와 시스템의 높은 회복탄력성을 확보할 수 있는 
이벤트 드리븐 아키텍처가 프로젝트에 가장 적합한 구조라고 판단했습니다.

---

### 📌 kafka 선택 이유:
이벤트 드리븐 아키텍처를 도입하기로 결정한 후, 대표적인 메시지 시스템인 카프카와 래빗엠큐를 비교하며
본 프로젝트에 더 적합한 솔루션이 무엇일까를 고민했습니다. 가상 자산 거래소나 관련 프로젝트에서는 수많은
사용자의 주문과 체결, 실시간으로 변동하는 시세 데이터 등 폭발적으로 쏟아지는 데이터를 어떻게 안정적으로
처리할 것인지가 가장 중요한 과제 중 하나입니다.

레빗엠큐는 복잡한 라우팅 규칙과 강력한 메시지 전달 보장 기능으로 잘 알려진 훌륭한 메시지 브로커입니다.
하지만 가상 자산 프로젝트의 '대용량 데이터 스트리밍'이라는 관점에서는 명확한 한계를 보였습니다.

1. 압도적인 처리량의 차이
- 메시지 시스템 선택에 가장 중요하게 고려한 것은 초당 수십만 건 이상의 메시지를 안정적으로 처리할 수 있는가였습니다.
- 레빗엠큐는 일반적으로 초당 수만 건의 메시지를 처리하는 데 최적화되어 있습니다. 클러스터링을 통해 성능을 높일 수는
있지만, 태생적으로 대용량 스트림 처리보다는 개별 메시지의 안정적인 전달에 초점을 맞추고 있습니다.
- 카프카는 분산 로그 아키텍처를 기반으로 설계되어 초당 수십만 건에서 수백만 건의 메시지를 손쉽게 처리합니다. 
이는 디스크에 순차적으로 데이터를 기록하는 방식으로, 대용량 데이터를 지연 없이 흡수하는 데 매우 효율적입니다.
쏟아지는 주문과 시세 데이터를 막힘없이 처리하기 위해서는 카프카의 처리량이 필수적이었습니다.

2. 데이터의 안정성과 영속성
- 가상 자산 거래에서 주문 데이터는 단순한 이벤트가 아니라 그 자체가 '자산'입니다. 만약 시스템에 장애가 발생하더라도
데이터는 반드시 보존되어야 합니다. 이 지점에서 레빗엠큐와 카프카는 데이터를 다루는 근본적인 철학의 차이를 보입니다.
- 카프카는 수신한 메시지를 설정된 기간 동안 디스크에 안전하게 보관합니다. 이러한 영속성은 매우 강력한 장점입니다. 
만약 특정 서비스에 장애가 발생하여 메시지를 소비하지 못하더라도, 서비스가 복구된 후 카프카에 저장된 지점부터 데이터를
다시 가져와 처리할 수 있습니다. 이는 장애 복구와 데이터 정합성 유지에 결정적인 역할을 합니다.
- 레빗엠큐 역시 메시지를 디스크에 저장하는 영속성 옵션을 제공하여 안정성을 보장합니다. 하지만 레빗엠큐의 영속성은
기본적으로 메시지가 컨슈머에게 안전하게 전달되고, 처리가 확인되면 큐에서 삭제되는 것을 전제로 합니다. 이는 
'처리해야 할 작업 목록'을 관리하는 데에는 매우 효과적이지만, 소비가 끝난 데이터를 다시 분석하거나 다른 서비스가
재사용하기는 어렵습니다.

#### ✨ 카프카 vs 레빗엠큐 비교 표:
| 구분   | RabbitMQ             | Kafka |
|------|----------------------|--|
| 주요 목적/강점 | 복잡한 조건에 따른 선별적 라우팅, 작업 큐 모델 | 대규모 실시간 데이터 스트리밍, 로그 수집, 이벤트 소싱 |
| 처리량 | 초당 수만 건              | 초당 수십만 ~ 수백만 건 |
| 데이터 처리 방식 | 메시지를 소비자에게 전달 후 삭제   | 데이터를 로그 형태로 지속적으로 보관 |
| 데이터 영속성 | 소비자가 처리 확인 후 큐에서 삭제됨 | 설정된 기간 동안 디스크에 보존 (소비 여부와 무관)|
| 장애 시 데이터 복구 | 소비되지 않은 메시지는 보존되나, 과거 데이터 재처리는 어려움 | 로그에 저장된 특정 시점부터 데이터 재처리 가능 |
<br>
위 글을 바탕으로 봤을 때, 레빗엠큐가 더 안좋은 기술이라는 의미는 아닙니다. 가령, 복잡한 조건에 따라 메시지를 
선별적으로 라우팅하거나, 여러 작업자에게 일을 분배하는 작업큐 모델 같은 특정 작업에 대해서는 레빗엠큐가 더 
적합할 수 있습니다. 하지만 가상 자산 프로젝트의 메인 데이터 파이프라인은 '대규모 데이터 스트림'을 처리하는 능력이 가장 
중요합니다. 이러한 관점에서 압도적인 처리량, 데이터의 안정성을 모두 갖춘 카프카는 선택이 아닌 필수였습니다.




















